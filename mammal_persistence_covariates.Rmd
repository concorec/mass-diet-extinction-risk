---
title: "mammal_persistence_covariates"
output: html_document
---

```{r}
###############################################################################
# 0. Packages and paths
###############################################################################

# Core data wrangling
library(dplyr)
library(tidyr)
library(purrr)
library(readr)
library(stringr)

# IUCN Red List API (requires REDLIST_API_KEY in your environment)
library(rredlist)

# ---------------------------------------------------------------------------
# Centralized file paths
# ---------------------------------------------------------------------------

PATHS <- list(
  # Raw inputs
  mammals_summary  = "Data/Raw/mammal_summary.csv",   # IUCN-based spatial summary
  mammal_weights   = "Data/Raw/mammal_data.txt",      # body mass + traits
  iucn_synonyms    = "Data/Raw/mammal_synonyms.csv",  # mapping between name variants
  random_effects   = "Data/Raw/random_effects.csv",   # Santini et al. (2018) random effects

  # Gompertz LOESS fits (from mammal_persistence_gompertz_fits.Rmd)
  loess_a          = "Data/Clean/mammal_loess_fit_a.rds",  # log10(a) ~ log10(mass)
  loess_b          = "Data/Clean/mammal_loess_fit_b.rds",  # b ~ log10(mass)

  # Final output
  out_mammal_data  = "Data/Clean/mammal_data.csv"
)
```

# 1. Helper functions for taxon strings and IUCN codes

```{r}
###############################################################################
# 1. Helper functions
###############################################################################

# ---------------------------------------------------------------------------
# 1.1 Standardise taxon strings for consistent joins
# ---------------------------------------------------------------------------
#
# Many sources differ only in whitespace / capitalisation, so we:
#   - trim extra spaces,
#   - collapse multiple spaces to one,
#   - convert to lowercase.
clean_taxon <- function(x) {
  x %>%
    str_squish() %>%  # collapse internal whitespace + trim
    tolower()
}

# ---------------------------------------------------------------------------
# 1.2 Normalise IUCN habitat codes like "14_4_1" → "14.4.1"
# ---------------------------------------------------------------------------
normalize_codes <- function(x) {
  x %>%
    as.character() %>%
    trimws() %>%
    gsub("_", ".", ., fixed = TRUE)
}

# ---------------------------------------------------------------------------
# 1.3 Group IUCN 14.x (Artificial - Terrestrial) into broad habitat classes
# ---------------------------------------------------------------------------
#
# Input:
#   hab_codes: character vector of IUCN habitat codes (e.g. "14.1", "14.4.1")
#
# Output:
#   character vector of broad artificial-terrestrial categories such as:
#     - "Arable & Pastureland"
#     - "Plantations & Heavily Degraded Former Forest"
#     - "Urban & Rural Gardens"
summarize_artificial_terrestrial <- function(hab_codes) {
  # If there are no codes at all, return empty vector (no artificial habitats)
  if (length(hab_codes) == 0) return(character(0))

  # Normalise codes and keep only those in the 14.x group
  codes    <- normalize_codes(hab_codes)
  at_codes <- codes[str_detect(codes, "^14(\\.|$)")]
  if (!length(at_codes)) return(character(0))

  # Pull out the Level-2 part (e.g. "14.1", "14.4" → 1, 4, etc.)
  lvl2_chr <- str_match(at_codes, "^14\\.(\\d+)")[, 2]
  lvl2     <- unique(suppressWarnings(as.integer(lvl2_chr)))
  lvl2     <- lvl2[!is.na(lvl2)]

  # Map groups of Level-2 codes to broad classes
  groups <- character(0)
  if (any(lvl2 %in% c(1, 2))) groups <- c(groups, "Arable & Pastureland")                        # 14.1 + 14.2
  if (any(lvl2 %in% c(3, 6))) groups <- c(groups, "Plantations & Heavily Degraded Former Forest") # 14.3 + 14.6
  if (any(lvl2 %in% c(4, 5))) groups <- c(groups, "Urban & Rural Gardens")                        # 14.4 + 14.5

  unique(groups)
}
```

# 2. Load mammals, reconcile names, and attach body mass / traits

```{r}
###############################################################################
# 2. Load mammals, weights, and synonyms; resolve names; attach masses
###############################################################################

# ---------------------------------------------------------------------------
# 2.1 Load base tables
# ---------------------------------------------------------------------------
#
# t_mammals      : IUCN spatial summary table (per-species range / area info)
# mammal_weights : body mass and other traits (EltonTraits-style)
# iucn_synonyms  : mapping between IUCN names and alternative scientific names
t_mammals      <- read_csv(PATHS$mammals_summary, show_col_types = FALSE)
mammal_weights <- read_tsv(PATHS$mammal_weights,  show_col_types = FALSE)
iucn_synonyms  <- read_csv(PATHS$iucn_synonyms,   show_col_types = FALSE)

# mammal_weights came from a format where hyphens are used; R converts them to
# dots by default, so we normalise explicitly to avoid surprises.
names(mammal_weights) <- gsub("-", ".", names(mammal_weights))

# ---------------------------------------------------------------------------
# 2.2 Clean taxonomic keys (lowercase, trimmed) for consistent joins
# ---------------------------------------------------------------------------

t_mammals <- t_mammals %>%
  mutate(scientificName = clean_taxon(scientificName))

iucn_synonyms <- iucn_synonyms %>%
  mutate(
    scientificName = clean_taxon(scientificName),
    candidate      = clean_taxon(paste(genusName, speciesName))
  )

mammal_weights <- mammal_weights %>%
  mutate(Scientific = clean_taxon(Scientific))

# ---------------------------------------------------------------------------
# 2.3 Keep only synonym candidates that actually exist in mammal_weights
# ---------------------------------------------------------------------------
#
# For each IUCN scientificName:
#   - keep at most one candidate that appears in mammal_weights$Scientific,
#   - this creates a compact mapping scientificName → candidate.
valid_synonyms <- iucn_synonyms %>%
  semi_join(mammal_weights, by = c("candidate" = "Scientific")) %>%
  group_by(scientificName) %>%
  slice(1) %>%   # if multiple candidates exist, pick the first
  ungroup() %>%
  dplyr::select(scientificName, candidate)

# ---------------------------------------------------------------------------
# 2.4 Resolve scientific names and attach trait / mass data
# ---------------------------------------------------------------------------
#
# For each row in t_mammals:
#   - if its scientificName exists in mammal_weights$Scientific, use that;
#   - otherwise, use the candidate synonym (if available);
#   - then join mammal_weights on the resolved name.
mammals <- t_mammals %>%
  left_join(valid_synonyms, by = "scientificName") %>%
  mutate(
    scientific_resolved = if_else(
      scientificName %in% mammal_weights$Scientific,
      scientificName,
      coalesce(candidate, scientificName)   # fallback: original IUCN name
    )
  ) %>%
  left_join(
    mammal_weights,
    by = c("scientific_resolved" = "Scientific")
  )
```

# 3. Diet aggregates and trophic category

```{r}
###############################################################################
# 3. Diet aggregates and trophic class
###############################################################################

# We collapse detailed Elton-style diet components into:
#   - Diet.AllPlants  : plant-based (fruit + nectar + seeds + other plants)
#   - Diet.AllAnimal : animal-based (invertebrates + vertebrates + scavenging)
# Then we assign a coarse trophic class (carnivore / herbivore / omnivore)
# based on ≥80% dominance of either plant or animal diet, when mass is known.

mammals <- mammals %>%
  mutate(
    # Aggregate detailed diet components (all in % of diet)
    Diet.VertFishScav = Diet.Vend + Diet.Vect + Diet.Vfish + Diet.Vunk + Diet.Scav,
    Diet.FruiNect     = Diet.Fruit + Diet.Nect,
    Diet.PlantSeed    = Diet.Seed  + Diet.PlantO,
    Diet.AllPlants    = Diet.FruiNect + Diet.PlantSeed,
    Diet.AllAnimal    = Diet.VertFishScav + Diet.Inv,

    # Dominant trophic class (if mass is missing, we leave diet as NA)
    Diet = case_when(
      is.na(BodyMass.Value) ~ NA_character_,
      Diet.AllAnimal >= 80  ~ "carnivore",
      Diet.AllPlants >= 80  ~ "herbivore",
      TRUE                  ~ "omnivore"
    )
  )
```

# 4. Random effects from Santini et al. and density model

```{r}
###############################################################################
# 4. Random effects (Order / Family / Species) and density estimates
###############################################################################

# ---------------------------------------------------------------------------
# 4.1 Load and attach random effects
# ---------------------------------------------------------------------------
#
# random_effects gives taxonomic random effects for log10 density, with:
#   - Effect_Order, Effect_Family, Effect_Species
# We:
#   - keep only Mammalia,
#   - clean taxon names,
#   - join by orderName, familyName, and resolved scientific name,
#   - replace missing effects with zero (no random deviation).
random_effects <- read_csv(PATHS$random_effects, show_col_types = FALSE) %>%
  filter(Class == "Mammalia") %>%
  mutate(
    Order   = clean_taxon(Order),
    Family  = clean_taxon(Family),
    Species = clean_taxon(Species)
  )

mammals <- mammals %>%
  mutate(
    orderName  = clean_taxon(orderName),
    familyName = clean_taxon(familyName)
  ) %>%
  # Attach order-level effect
  left_join(
    random_effects %>% distinct(Order, Effect_Order),
    by = c("orderName" = "Order")
  ) %>%
  # Attach family-level effect
  left_join(
    random_effects %>% distinct(Family, Effect_Family),
    by = c("familyName" = "Family")
  ) %>%
  # Attach species-level effect (aligned with scientific_resolved)
  left_join(
    random_effects %>% distinct(Species, Effect_Species),
    by = c("scientific_resolved" = "Species")
  ) %>%
  mutate(
    Effect_Order   = replace_na(Effect_Order,   0),
    Effect_Family  = replace_na(Effect_Family,  0),
    Effect_Species = replace_na(Effect_Species, 0)
  )

# ---------------------------------------------------------------------------
# 4.2 Log10-density model coefficients (Santini-style)
# ---------------------------------------------------------------------------
#
# Model:
#   log10(density) =
#     B0 + Effect_Order + Effect_Family + Effect_Species +
#     effect_diet + B_mass * log10(BodyMass.Value)
#
# where effect_diet depends on trophic class (carnivore as reference).
B0          <-  2.4814753048
B_diet_herb <- -0.1003301887
B_diet_omni <- -0.0552981064
B_diet_carn <-  0.0       # reference
B_mass      <- -0.3296510182

# ---------------------------------------------------------------------------
# 4.3 Predict log10 density and density (ind / km²)
# ---------------------------------------------------------------------------

mammals <- mammals %>%
  mutate(
    # Diet-specific fixed effect
    effect_diet = case_when(
      Diet == "herbivore" ~ B_diet_herb,
      Diet == "omnivore"  ~ B_diet_omni,
      Diet == "carnivore" ~ B_diet_carn,
      TRUE                ~ 0   # unknown diet → no additional effect
    ),

    # Log10 density prediction (can be NA if BodyMass.Value is NA)
    log10_density = B0 +
      Effect_Order + Effect_Family + Effect_Species +
      effect_diet + B_mass * log10(BodyMass.Value),

    # Back-transform to density (individuals per km²)
    density = 10^log10_density
  )
```

# 5. Home range, dispersal distance, and minimum patch sizes

```{r}
###############################################################################
# 5. Home range, dispersal distance, minimum patch sizes
###############################################################################

# Using body mass, trophic class, and density, we derive:
#   - home_range_size (km²),
#   - dispersal_dist (km),
#   - min_patch_size (km²) for ~10 individuals,
#   - min_patch_size500 (km²) for ~500 individuals.
#
# Home range scaling:
#   carnivores: HR ≈ 0.38 * M^1.13   (M in kg)
#   others   : HR ≈ 0.054 * M       (M in kg)
mammals <- mammals %>%
  mutate(
    # Convert body mass from grams to kilograms
    body_mass_kg = BodyMass.Value / 1000,

    # Diet-specific home range scaling (area in km²)
    home_range_size = if_else(
      Diet == "carnivore",
      0.38 * body_mass_kg^1.13,
      0.054 * body_mass_kg
    ),

    # Dispersal distance as a function of home range (km)
    dispersal_dist = 5.6 * sqrt(home_range_size),

    # Minimum patch areas that can hold ~10 and ~500 individuals
    min_patch_size    = 10  / density,
    min_patch_size500 = 500 / density
  )
```

# 6. IUCN habitats: Level-1 and grouped artificial terrestrial categories

```{r}
###############################################################################
# 6. IUCN habitats → Level-1 classes and grouped 14.x categories
###############################################################################

# ---------------------------------------------------------------------------
# 6.1 Lookup: IUCN Level-1 code → descriptive label
# ---------------------------------------------------------------------------

level1_lookup <- c(
  `1`  = "Forest",
  `2`  = "Savanna",
  `3`  = "Shrubland",
  `4`  = "Grassland",
  `5`  = "Wetlands (inland)",
  `6`  = "Rocky Areas",
  `7`  = "Caves & Subterranean (non-aquatic)",
  `8`  = "Desert",
  `9`  = "Marine Neritic",
  `10` = "Marine Oceanic",
  `11` = "Marine Deep Ocean Floor",
  `12` = "Marine Intertidal",
  `13` = "Marine Coastal/Supratidal",
  `14` = "Artificial - Terrestrial",
  `15` = "Artificial - Aquatic",
  `16` = "Introduced Vegetation",
  `17` = "Other",
  `18` = "Unknown"
)

# ---------------------------------------------------------------------------
# 6.2 Helper: get habitats for one taxon via IUCN API
# ---------------------------------------------------------------------------
#
# For a given (genus, species):
#   - call rl_species_latest() to get latest species-level assessment,
#   - keep only habitats with suitability == "suitable",
#   - map codes to:
#       * level1_habitats : full Level-1 labels (including 14),
#       * habitats_mixed  : Level-1 labels excluding 14 +
#                           broad artificial-terrestrial categories for 14.x.
#
# Returns a tibble with one row and two character columns.
get_habitats_one <- function(genus, species) {
  # Safely call IUCN API (NULL on failure instead of crashing)
  res <- purrr::possibly(
    rl_species_latest,
    otherwise = NULL
  )(genus = trimws(genus), species = trimws(species), scope = "1", parse = TRUE)

  # If no data or no habitats, return NA placeholders
  if (is.null(res) || is.null(res$habitats) || nrow(res$habitats) == 0) {
    return(tibble(
      level1_habitats = NA_character_,
      habitats_mixed  = NA_character_
    ))
  }

  # Keep only habitats marked as "suitable"
  hab <- res$habitats %>%
    mutate(suitability = tolower(trimws(as.character(suitability)))) %>%
    filter(suitability == "suitable")

  if (nrow(hab) == 0) {
    return(tibble(
      level1_habitats = NA_character_,
      habitats_mixed  = NA_character_
    ))
  }

  # Normalise codes (e.g. "14_4_1" → "14.4.1")
  codes <- normalize_codes(hab$code)

  # Extract Level-1 numeric codes from the start of each code
  lvl1_codes <- suppressWarnings(as.integer(str_extract(codes, "^\\d+")))
  lvl1_codes <- lvl1_codes[!is.na(lvl1_codes)]

  # All Level-1 names (including 14)
  lvl1_names <- unique(unname(level1_lookup[as.character(lvl1_codes)]))
  lvl1_str   <- if (length(lvl1_names)) paste(lvl1_names, collapse = ", ") else NA_character_

  # "Mixed" summary:
  #   - Level-1 names excluding 14 ("Artificial - Terrestrial"),
  #   - plus grouped 14.x categories via summarize_artificial_terrestrial().
  lvl1_except14 <- unique(unname(level1_lookup[as.character(lvl1_codes[lvl1_codes != 14])]))
  lvl1_except14 <- lvl1_except14[!is.na(lvl1_except14)]

  grouped_14 <- summarize_artificial_terrestrial(codes)

  mixed_vec <- unique(c(lvl1_except14, grouped_14))
  mixed_str <- if (length(mixed_vec)) paste(mixed_vec, collapse = ", ") else NA_character_

  tibble(
    level1_habitats = lvl1_str,
    habitats_mixed  = mixed_str
  )
}

# ---------------------------------------------------------------------------
# 6.3 Query IUCN once per unique (genus, species) pair and join back
# ---------------------------------------------------------------------------
#
# We:
#   - extract unique genusName + speciesName pairs from mammals,
#   - call get_habitats_one() for each,
#   - attach level1_habitats and habitats_mixed to the main mammals table.

# Unique species for IUCN API calls
species_tbl <- mammals %>%
  distinct(genusName, speciesName) %>%
  filter(!is.na(genusName), !is.na(speciesName))

# For each species, fetch its habitats and unpack the small tibble
hab_map <- species_tbl %>%
  mutate(hab = map2(genusName, speciesName, get_habitats_one)) %>%
  unnest_wider(hab)

# Join habitat summaries back to the per-species mammals table
mammals <- mammals %>%
  left_join(hab_map, by = c("genusName", "speciesName"))
```

# 7. Gompertz parameters per species from LOESS fits

```{r}
###############################################################################
# 7. Gompertz parameters per species (a_pred, b_pred)
###############################################################################

# Load LOESS models from the Gompertz-fitting script:
#   loess_fit_a: predicts log10(a) from log10(Mass)
#   loess_fit_b: predicts b from log10(Mass)
loess_fit_a <- readRDS(PATHS$loess_a)
loess_fit_b <- readRDS(PATHS$loess_b)

# Predictor: log10 body mass in the same units used in the LOESS fits
mass_log10 <- log10(mammals$BodyMass.Value)

# Predict per-species parameter values:
#   a_pred = 10^(predicted log10(a))
#   b_pred = predicted b
mammals <- mammals %>%
  mutate(
    a_pred = 10 ^ predict(loess_fit_a, newdata = data.frame(logM = mass_log10)),
    b_pred =      predict(loess_fit_b, newdata = data.frame(logM = mass_log10))
  )
```

# 8. Final export

```{r}
###############################################################################
# 8. Final export
###############################################################################

# The final table "mammals" now contains:
#   - Spatial info + IUCN IDs,
#   - Resolved scientific names and traits (mass, diet),
#   - Trophic class (Diet),
#   - Random effects and predicted density,
#   - Home range, dispersal distance, minimum patch sizes,
#   - IUCN habitat summaries (level1_habitats, habitats_mixed),
#   - Gompertz parameters (a_pred, b_pred) for persistence curves.
write_csv(mammals, PATHS$out_mammal_data)
```