---
title: "mammal_persistence_gompertz_fits"
output: html_document
---

```{r}
###############################################################################
# 0. Packages, constants, and paths (birds, all diet combinations)
###############################################################################

# Data handling and functional programming
library(dplyr)
library(purrr)
library(tidyr)
library(tibble)

# Plotting (optional; kept for symmetry with mammal script)
library(ggplot2)
library(patchwork)
library(scales)
library(grid)   # for unit() in legend sizing

# ---------------------------------------------------------------------------
# Model constants
# ---------------------------------------------------------------------------

# Shift used in the modified Gompertz model:
#   p(K) = exp( -a * (K - K_SHIFT)^(-b) ),  for K > K_SHIFT
K_SHIFT <- 500

# Bird mass grid (31 log-spaced values, consistent with prediction scripts)
bird_masses <- 10^seq(log10(2), log10(11236), length.out = 31)

# ---------------------------------------------------------------------------
# File paths (inputs from persistence_simulations, outputs are LOESS models)
# ---------------------------------------------------------------------------

PATHS <- list(
  results_birds   = "Data/Results/birds",
  ilr_effects_in  = "Data/Clean/ilr_effects.csv",  # contains 'combo' column
  loess_dir_birds = "Data/Clean"
)

# Load ILR effects to get the list of diet combinations (strings like "100_0_0")
ilr_effects <- readr::read_csv(PATHS$ilr_effects_in, show_col_types = FALSE)
diet_combos <- ilr_effects$combo   # vector of combo labels used throughout
```

# 1. Load persistence curves (K × p) from simulations

```{r}
###############################################################################
# 1. Helper functions: modified Gompertz fits (unchanged form)
###############################################################################

# ---------------------------------------------------------------------------
# 1.1 Helper: fit shifted Gompertz for one mass index
# ---------------------------------------------------------------------------
#
# Model:
#   p(K) = exp( -a * (K - K_SHIFT)^(-b) ),  for K > K_SHIFT
#
# Implementation detail:
#   - We reparameterise as y = exp(-a * exp(-b * log(x))) with x = K - K_SHIFT.
#   - This lets us fit via nls() with good starting values from a linearization.
#
# Args:
#   K     : numeric vector of starting population sizes
#   p     : numeric vector of persistence probabilities (in (0,1))
#   shift : horizontal shift (here always K_SHIFT = 500)
#
# Returns:
#   list(a, b, r2) for this (mass-specific) curve
fit_modified_gompertz <- function(K, p, shift = K_SHIFT) {
  # Shift K to positive domain: x = K - shift
  x <- K - shift
  y <- p

  # Get starting values from a simple linear relationship:
  #   log(-log(y)) ~ log(x)
  Xt <- log(x)
  Yt <- log(-log(y))
  lm_fit <- lm(Yt ~ Xt)

  a0 <- as.numeric(exp(coef(lm_fit)[1]))   # initial a
  b0 <- as.numeric(-coef(lm_fit)[2])       # initial b (note minus sign)

  # Small deterministic grid of starting values around (a0, b0)
  a_grid <- a0 * c(0.25, 0.5, 1, 2, 4)
  b_grid <- b0 * c(0.25, 0.5, 1, 2, 4)
  start_grid <- expand.grid(a = a_grid, b = b_grid)

  # Inner helper: attempt one nls() fit
  attempt <- function(a_start, b_start, iters) {
    suppressWarnings(
      try(
        nls(
          y ~ exp(-a * exp(-b * log(x))),        # equivalent to exp(-a * x^(-b))
          start     = list(a = a_start, b = b_start),
          algorithm = "port",
          lower     = c(a = 1e-12, b = 1e-12),
          control   = nls.control(warnOnly = TRUE, maxiter = iters)
        ),
        silent = TRUE
      )
    )
  }

  fit <- NULL

  # 1) Deterministic multi-start over the grid
  for (k in seq_len(nrow(start_grid))) {
    cand <- attempt(start_grid$a[k], start_grid$b[k], iters = 200)
    if (!inherits(cand, "try-error")) {
      ci <- cand$convInfo
      if (!is.null(ci) && isTRUE(ci$isConv)) {
        fit <- cand
        break
      }
    }
  }

  # 2) Random restarts around (a0, b0) if the grid failed
  if (is.null(fit)) {
    set.seed(123)
    for (j in 1:30) {
      ai <- a0 * exp(runif(1, log(0.1), log(10)))
      bi <- b0 * exp(runif(1, log(0.1), log(10)))
      cand <- attempt(ai, bi, iters = 300)
      if (!inherits(cand, "try-error")) {
        ci <- cand$convInfo
        if (!is.null(ci) && isTRUE(ci$isConv)) {
          fit <- cand
          break
        }
      }
    }
  }

  if (is.null(fit)) {
    stop("Modified Gompertz fit failed for one of the mass indices; check inputs.")
  }

  # Extract parameters and compute pseudo-R² on observed points
  coefs  <- coef(fit)
  a_hat  <- unname(coefs["a"])
  b_hat  <- unname(coefs["b"])
  y_pred <- as.numeric(predict(fit, newdata = data.frame(x = x)))

  rss <- sum((y - y_pred)^2)
  tss <- sum((y - mean(y))^2)
  r2  <- if (tss > 0) 1 - rss / tss else NA_real_

  list(a = a_hat, b = b_hat, r2 = r2)
}
```

# 2. Fit Gompertz curves per mass index

One flavour:

Modified “shifted” Gompertz (main model used later):

p(K)=exp{−a(K−K_SHIFT)^(−b)}

```{r}
###############################################################################
# 2. Fit Gompertz curves for each mass
###############################################################################

# ---------------------------------------------------------------------------
# 2.1 Helper: fit shifted Gompertz for one mass index
# ---------------------------------------------------------------------------
#
# Model:
#   p(K) = exp( -a * (K - K_SHIFT)^(-b) ),  for K > K_SHIFT
#
# Implementation detail:
#   - We reparameterise as y = exp(-a * exp(-b * log(x))) with x = K - K_SHIFT.
#   - This lets us fit via nls() with good starting values from a linearization.
#
# Args:
#   K     : numeric vector of starting population sizes
#   p     : numeric vector of persistence probabilities (in (0,1))
#   shift : horizontal shift (here always K_SHIFT = 500)
#
# Returns:
#   list(a, b, r2) for this (mass-specific) curve
fit_modified_gompertz <- function(K, p, shift = K_SHIFT) {
  # Shift K to positive domain: x = K - shift
  x <- K - shift
  y <- p

  # Get starting values from a simple linear relationship:
  #   log(-log(y)) ~ log(x)
  Xt <- log(x)
  Yt <- log(-log(y))
  lm_fit <- lm(Yt ~ Xt)

  a0 <- as.numeric(exp(coef(lm_fit)[1]))   # initial a
  b0 <- as.numeric(-coef(lm_fit)[2])       # initial b (note minus sign)

  # Small deterministic grid of starting values around (a0, b0)
  a_grid <- a0 * c(0.25, 0.5, 1, 2, 4)
  b_grid <- b0 * c(0.25, 0.5, 1, 2, 4)
  start_grid <- expand.grid(a = a_grid, b = b_grid)

  # Inner helper: attempt one nls() fit
  attempt <- function(a_start, b_start, iters) {
    suppressWarnings(
      try(
        nls(
          y ~ exp(-a * exp(-b * log(x))),        # equivalent to exp(-a * x^(-b))
          start     = list(a = a_start, b = b_start),
          algorithm = "port",
          lower     = c(a = 1e-12, b = 1e-12),
          control   = nls.control(warnOnly = TRUE, maxiter = iters)
        ),
        silent = TRUE
      )
    )
  }

  fit <- NULL

  # 1) Deterministic multi-start over the grid
  for (k in seq_len(nrow(start_grid))) {
    cand <- attempt(start_grid$a[k], start_grid$b[k], iters = 200)
    if (!inherits(cand, "try-error")) {
      ci <- cand$convInfo
      if (!is.null(ci) && isTRUE(ci$isConv)) {
        fit <- cand
        break
      }
    }
  }

  # 2) Random restarts around (a0, b0) if the grid failed
  if (is.null(fit)) {
    set.seed(123)
    for (j in 1:30) {
      ai <- a0 * exp(runif(1, log(0.1), log(10)))
      bi <- b0 * exp(runif(1, log(0.1), log(10)))
      cand <- attempt(ai, bi, iters = 300)
      if (!inherits(cand, "try-error")) {
        ci <- cand$convInfo
        if (!is.null(ci) && isTRUE(ci$isConv)) {
          fit <- cand
          break
        }
      }
    }
  }

  if (is.null(fit)) {
    stop("Modified Gompertz fit failed for one of the mass indices; check inputs.")
  }

  # Extract parameters and compute pseudo-R² on observed points
  coefs  <- coef(fit)
  a_hat  <- unname(coefs["a"])
  b_hat  <- unname(coefs["b"])
  y_pred <- as.numeric(predict(fit, newdata = data.frame(x = x)))

  rss <- sum((y - y_pred)^2)
  tss <- sum((y - mean(y))^2)
  r2  <- if (tss > 0) 1 - rss / tss else NA_real_

  list(a = a_hat, b = b_hat, r2 = r2)
}

# ---------------------------------------------------------------------------
# 2.2 Apply modified Gompertz fit to all mass indices
# ---------------------------------------------------------------------------

# Fit the shifted Gompertz curve for each column (mass-specific persistence curve)
fit_list <- map(
  seq_len(n_mass),
  ~ fit_modified_gompertz(
    K = starting_pops[, .x],
    p = persistence_probs[, .x]
  )
)

# Collect as a tidy parameter table:
#   - a, b, r² for each of the 31 mass grid points
#   - Mass = body mass corresponding to that index
fit_results_df <- map_dfr(seq_len(n_mass), function(i) {
  fr <- fit_list[[i]]
  tibble(
    mass_index = i,
    Mass       = masses[i],
    a          = fr$a,
    b          = fr$b,
    r2         = fr$r2
  )
})
```

# 3. LOESS smoothing of Gompertz parameters vs mass

We now smooth the fitted parameters a(M) and b(M) over body mass, and save the LOESS objects for use in later scripts.

```{r}
###############################################################################
# 2–3. Loop over all diet combinations: load curves, fit Gompertz, fit LOESS
###############################################################################

# Optional: store everything in a list for in-session use (indexed by combo)
bird_loess_all <- vector("list", length(diet_combos))
names(bird_loess_all) <- diet_combos

for (diet_combo in diet_combos) {

  message("Processing diet combo: ", diet_combo)

  #############################################################################
  # 2. Load starting population sizes (K) and persistence probabilities
  #    for this specific diet combination
  #############################################################################

  # These CSVs were written by the Ricker simulation script for birds.
  # Filenames follow the convention:
  #   bird_<combo>_starting_pops.csv
  #   bird_<combo>_persistence_probs.csv
  #
  # Each file has one column per mass-grid entry (mass_1, mass_2, ...),
  # and one row per K value in the simulated persistence curve.

  starting_pops <- read.csv(
    file.path(PATHS$results_birds, paste0("bird_", diet_combo, "_starting_pops.csv")),
    row.names   = 1,
    check.names = FALSE
  )

  persistence_probs <- read.csv(
    file.path(PATHS$results_birds, paste0("bird_", diet_combo, "_persistence_probs.csv")),
    row.names   = 1,
    check.names = FALSE
  )

  # Convert to numeric matrices for fast column-wise access
  starting_pops_mat     <- as.matrix(starting_pops)
  persistence_probs_mat <- as.matrix(persistence_probs)

  # To safely take log(-log(p)), we must keep p strictly in (0,1).
  # Clamp any numerical 0 or 1 values slightly inward:
  persistence_probs_mat[persistence_probs_mat <= 0] <- 0.0001
  persistence_probs_mat[persistence_probs_mat >= 1] <- 0.9999

  # Number of mass-grid points; should match length(bird_masses) = 31
  n_mass <- ncol(starting_pops_mat)

  #############################################################################
  # 3. Fit Gompertz curves and LOESS smooths for this diet combination
  #############################################################################

  # 3.1 Apply modified Gompertz fit to all mass indices
  #
  # Fit the shifted Gompertz curve for each column (mass-specific persistence curve)
  fit_list <- purrr::map(
    seq_len(n_mass),
    ~ fit_modified_gompertz(
      K = starting_pops_mat[, .x],
      p = persistence_probs_mat[, .x]
    )
  )

  # Collect as a tidy parameter table:
  #   - a, b, r² for each of the 31 mass grid points
  #   - Mass = body mass corresponding to that index
  fit_results_df <- purrr::map_dfr(seq_len(n_mass), function(i) {
    fr <- fit_list[[i]]
    tibble(
      mass_index = i,
      Mass       = bird_masses[i],
      a          = fr$a,
      b          = fr$b,
      r2         = fr$r2
    )
  })

  # 3.2 LOESS smooths of Gompertz parameters vs body mass
  #
  # Construct a compact table with:
  #   logM = log10 body mass (g)
  #   loga = log10(a) from the Gompertz fits
  #   b    = b from the Gompertz fits
  df_params <- tibble(
    logM = log10(bird_masses),
    loga = log10(fit_results_df$a),
    b    = fit_results_df$b
  ) %>%
    dplyr::filter(
      is.finite(logM),
      is.finite(loga),
      is.finite(b)
    )

  # Fit LOESS models:
  #   log10(a) ~ log10(Mass)
  #   b        ~ log10(Mass)
  loess_fit_a <- loess(loga ~ logM, data = df_params, span = 0.5)
  loess_fit_b <- loess(b    ~ logM, data = df_params, span = 0.5)

  # Save LOESS models for downstream use, with filenames keyed by diet combo
  saveRDS(
    loess_fit_a,
    file.path(PATHS$loess_dir_birds, paste0("bird_loess_fit_a_", diet_combo, ".rds"))
  )
  saveRDS(
    loess_fit_b,
    file.path(PATHS$loess_dir_birds, paste0("bird_loess_fit_b_", diet_combo, ".rds"))
  )

  # (Optional) Keep in memory as well
  bird_loess_all[[diet_combo]] <- list(
    combo          = diet_combo,
    fit_results_df = fit_results_df,
    loess_fit_a    = loess_fit_a,
    loess_fit_b    = loess_fit_b
  )
}
```
