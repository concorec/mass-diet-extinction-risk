---
title: "mammal_persistence_gompertz_fits"
output: html_document
---

```{r}
###############################################################################
# 0. Packages, constants, and paths
###############################################################################

# Data handling and functional programming
library(dplyr)
library(purrr)
library(tidyr)
library(tibble)

# Plotting
library(ggplot2)
library(patchwork)
library(scales)
library(grid)   # for unit() in legend sizing

# ---------------------------------------------------------------------------
# Model constants
# ---------------------------------------------------------------------------

# Shift used in the modified Gompertz model:
#   p(K) = exp( -a * (K - K_SHIFT)^(-b) ),  for K > K_SHIFT
K_SHIFT <- 500

# Density of Loxodonta africana (used to convert K → area in Figure 2)
D_LOXODONTA <- 0.04360361   # individuals per km²

# Mammal mass grid (31 log-spaced values, consistent with previous scripts)
masses <- 10^seq(log10(2), log10(4750000), length.out = 31)

# ---------------------------------------------------------------------------
# File paths (inputs from persistence_simulations, outputs are figures and RDS)
# ---------------------------------------------------------------------------

PATHS <- list(
  starting_pops     = "Data/Results/mammals/mammal_starting_pops.csv",
  persistence_probs = "Data/Results/mammals/mammal_persistence_probs.csv",
  loess_a_out       = "Data/Clean/mammal_loess_fit_a.rds",
  loess_b_out       = "Data/Clean/mammal_loess_fit_b.rds"
)
```

# 1. Load persistence curves (K × p) from simulations

```{r}
###############################################################################
# 1. Load starting population sizes (K) and persistence probabilities
###############################################################################

# These CSVs were written by the Ricker simulation script.
# They have one column per mass-grid entry (mass_1, mass_2, ...),
# and one row per K value in the simulated persistence curve.

# We read with row.names = 1 because the first column stores K "names"
starting_pops <- read.csv(
  PATHS$starting_pops,
  row.names   = 1,
  check.names = FALSE
)

persistence_probs <- read.csv(
  PATHS$persistence_probs,
  row.names   = 1,
  check.names = FALSE
)

# Convert to numeric matrices for fast column-wise access
starting_pops     <- as.matrix(starting_pops)
persistence_probs <- as.matrix(persistence_probs)

# To safely take log(-log(p)), we must keep p strictly in (0,1).
# Clamp any numerical 0 or 1 values slightly inward:
persistence_probs[persistence_probs <= 0] <- 0.0001
persistence_probs[persistence_probs >= 1] <- 0.9999

# Number of mass-grid points; should match length(masses) = 31
n_mass <- ncol(starting_pops)
```

# 2. Fit Gompertz curves per mass index

Two flavours:

Modified “shifted” Gompertz (main model used later):

p(K)=exp{−a(K−K_SHIFT)^(−b)}

Original Wolff-style Gompertz with fixed A = 10 (for comparison in Figure 1):

p(K)=exp{−10exp(−cK)}

```{r}
###############################################################################
# 2. Fit Gompertz curves for each mass
###############################################################################

# ---------------------------------------------------------------------------
# 2.1 Helper: fit shifted Gompertz for one mass index
# ---------------------------------------------------------------------------
#
# Model:
#   p(K) = exp( -a * (K - K_SHIFT)^(-b) ),  for K > K_SHIFT
#
# Implementation detail:
#   - We reparameterise as y = exp(-a * exp(-b * log(x))) with x = K - K_SHIFT.
#   - This lets us fit via nls() with good starting values from a linearization.
#
# Args:
#   K     : numeric vector of starting population sizes
#   p     : numeric vector of persistence probabilities (in (0,1))
#   shift : horizontal shift (here always K_SHIFT = 500)
#
# Returns:
#   list(a, b, r2) for this (mass-specific) curve
fit_modified_gompertz <- function(K, p, shift = K_SHIFT) {
  # Shift K to positive domain: x = K - shift
  x <- K - shift
  y <- p

  # Get starting values from a simple linear relationship:
  #   log(-log(y)) ~ log(x)
  Xt <- log(x)
  Yt <- log(-log(y))
  lm_fit <- lm(Yt ~ Xt)

  a0 <- as.numeric(exp(coef(lm_fit)[1]))   # initial a
  b0 <- as.numeric(-coef(lm_fit)[2])       # initial b (note minus sign)

  # Small deterministic grid of starting values around (a0, b0)
  a_grid <- a0 * c(0.25, 0.5, 1, 2, 4)
  b_grid <- b0 * c(0.25, 0.5, 1, 2, 4)
  start_grid <- expand.grid(a = a_grid, b = b_grid)

  # Inner helper: attempt one nls() fit
  attempt <- function(a_start, b_start, iters) {
    suppressWarnings(
      try(
        nls(
          y ~ exp(-a * exp(-b * log(x))),        # equivalent to exp(-a * x^(-b))
          start     = list(a = a_start, b = b_start),
          algorithm = "port",
          lower     = c(a = 1e-12, b = 1e-12),
          control   = nls.control(warnOnly = TRUE, maxiter = iters)
        ),
        silent = TRUE
      )
    )
  }

  fit <- NULL

  # 1) Deterministic multi-start over the grid
  for (k in seq_len(nrow(start_grid))) {
    cand <- attempt(start_grid$a[k], start_grid$b[k], iters = 200)
    if (!inherits(cand, "try-error")) {
      ci <- cand$convInfo
      if (!is.null(ci) && isTRUE(ci$isConv)) {
        fit <- cand
        break
      }
    }
  }

  # 2) Random restarts around (a0, b0) if the grid failed
  if (is.null(fit)) {
    set.seed(123)
    for (j in 1:30) {
      ai <- a0 * exp(runif(1, log(0.1), log(10)))
      bi <- b0 * exp(runif(1, log(0.1), log(10)))
      cand <- attempt(ai, bi, iters = 300)
      if (!inherits(cand, "try-error")) {
        ci <- cand$convInfo
        if (!is.null(ci) && isTRUE(ci$isConv)) {
          fit <- cand
          break
        }
      }
    }
  }

  if (is.null(fit)) {
    stop("Modified Gompertz fit failed for one of the mass indices; check inputs.")
  }

  # Extract parameters and compute pseudo-R² on observed points
  coefs  <- coef(fit)
  a_hat  <- unname(coefs["a"])
  b_hat  <- unname(coefs["b"])
  y_pred <- as.numeric(predict(fit, newdata = data.frame(x = x)))

  rss <- sum((y - y_pred)^2)
  tss <- sum((y - mean(y))^2)
  r2  <- if (tss > 0) 1 - rss / tss else NA_real_

  list(a = a_hat, b = b_hat, r2 = r2)
}

# ---------------------------------------------------------------------------
# 2.2 Helper: Wolff-style Gompertz with fixed A = 10
# ---------------------------------------------------------------------------
#
# Model:
#   p(K) = exp( -10 * exp(-c * K) )
#
# This has a single shape parameter c; we fit it for the elephant example only.
#
# Args:
#   K : starting population sizes
#   p : persistence probabilities
#
# Returns:
#   list(c, r2)
fit_fixedA_gompertz <- function(K, p) {
  y  <- p
  Yt <- log(-log(y))      # log(-log(p))
  lm_fit <- lm(Yt ~ K)    # slope ≈ -c
  c0 <- as.numeric(-coef(lm_fit)[2])

  c_grid <- c0 * c(0.25, 0.5, 1, 2, 4)

  attempt <- function(c_start, iters) {
    suppressWarnings(
      try(
        nls(
          y ~ exp(-10 * exp(-c * K)),
          start     = list(c = c_start),
          algorithm = "port",
          lower     = c(c = 1e-12),
          control   = nls.control(warnOnly = TRUE, maxiter = iters)
        ),
        silent = TRUE
      )
    )
  }

  fit <- NULL

  # Deterministic grid search
  for (k in seq_along(c_grid)) {
    cand <- attempt(c_grid[k], iters = 200)
    if (!inherits(cand, "try-error")) {
      ci <- cand$convInfo
      if (!is.null(ci) && isTRUE(ci$isConv)) {
        fit <- cand
        break
      }
    }
  }

  # Random restarts if needed
  if (is.null(fit)) {
    set.seed(123)
    for (j in 1:30) {
      cj <- c0 * exp(runif(1, log(0.1), log(10)))
      cand <- attempt(cj, iters = 300)
      if (!inherits(cand, "try-error")) {
        ci <- cand$convInfo
        if (!is.null(ci) && isTRUE(ci$isConv)) {
          fit <- cand
          break
        }
      }
    }
  }

  if (is.null(fit)) {
    stop("Fixed-A (A=10) Gompertz fit failed; check inputs.")
  }

  c_hat  <- as.numeric(coef(fit)["c"])
  y_pred <- as.numeric(predict(fit, newdata = data.frame(K = K)))

  rss <- sum((y - y_pred)^2)
  tss <- sum((y - mean(y))^2)
  r2  <- if (tss > 0) 1 - rss / tss else NA_real_

  list(c = c_hat, r2 = r2)
}

# ---------------------------------------------------------------------------
# 2.3 Apply modified Gompertz fit to all mass indices
# ---------------------------------------------------------------------------

# Fit the shifted Gompertz curve for each column (mass-specific persistence curve)
fit_list <- map(
  seq_len(n_mass),
  ~ fit_modified_gompertz(
    K = starting_pops[, .x],
    p = persistence_probs[, .x]
  )
)

# Collect as a tidy parameter table:
#   - a, b, r² for each of the 31 mass grid points
#   - Mass = body mass corresponding to that index
fit_results_df <- map_dfr(seq_len(n_mass), function(i) {
  fr <- fit_list[[i]]
  tibble(
    mass_index = i,
    Mass       = masses[i],
    a          = fr$a,
    b          = fr$b,
    r2         = fr$r2
  )
})
```

# 3. LOESS smoothing of Gompertz parameters vs mass

We now smooth the fitted parameters a(M) and b(M) over body mass, and save the LOESS objects for use in later scripts.

```{r}
###############################################################################
# 3. LOESS smooths of Gompertz parameters vs body mass
###############################################################################

# Construct a compact table with:
#   logM = log10 body mass (g)
#   loga = log10(a) from the Gompertz fits
#   b    = b from the Gompertz fits
df_params <- tibble(
  logM = log10(masses),
  loga = log10(fit_results_df$a),
  b    = fit_results_df$b
) %>%
  filter(
    is.finite(logM),
    is.finite(loga),
    is.finite(b)
  )

# Fit LOESS models:
#   log10(a) ~ log10(Mass)
#   b        ~ log10(Mass)
loess_fit_a <- loess(loga ~ logM, data = df_params, span = 0.5)
loess_fit_b <- loess(b    ~ logM, data = df_params, span = 0.5)

# Save LOESS models for downstream use (e.g. species-level parameter assignment)
saveRDS(loess_fit_a, PATHS$loess_a_out)
saveRDS(loess_fit_b, PATHS$loess_b_out)
```

# 4. Shared plotting helpers

Define a basic theme, the shifted Gompertz function, and a small helper to find the K that gives a chosen persistence level.

```{r}
###############################################################################
# 4. Plotting helpers: themes and Gompertz utilities
###############################################################################

neutral_blue <- "#3A6FB0"

# Base theme for most plots (used and extended below)
theme_clean <- function(base_size = 12) {
  theme_minimal(base_size = base_size) +
    theme(
      axis.title         = element_text(face = "bold"),
      axis.text          = element_text(color = "grey20"),
      panel.grid.minor   = element_blank(),
      panel.grid.major.x = element_blank(),
      panel.grid.major.y = element_line(color = "grey90"),
      panel.border       = element_rect(color = "grey60", fill = NA, linewidth = 0.6),
      plot.title         = element_text(face = "bold"),
      legend.position    = "none",
      plot.margin        = margin(6, 6, 6, 6)
    )
}

# Shifted Gompertz (the main model):
#   p(K) = exp( -a * (K - shift)^(-b) ), for K > shift
gompertz_shifted <- function(K, a, b, shift = K_SHIFT) {
  z <- K - shift
  exp(-a * z^(-b))
}

# K value corresponding to a given persistence p under the shifted Gompertz model
K_at_p <- function(a, b, shift = K_SHIFT, p = 0.8) {
  shift + (a / -log(p))^(1 / b)
}
```

# 5. Figure 1 – Loxodonta africana: shifted vs original Gompertz

```{r}
###############################################################################
# 5. Figure 1: Elephant (Loxodonta africana) – shifted vs original Gompertz
###############################################################################

# Use the last mass index (largest body mass) as the elephant example
i_ele <- ncol(starting_pops)

# Observed K and persistence probabilities from simulations
x_obs <- as.numeric(starting_pops[, i_ele])
y_obs <- as.numeric(persistence_probs[, i_ele])

# Parameters for the shifted Gompertz model at this mass
a_ele      <- fit_results_df$a[i_ele]
b_ele      <- fit_results_df$b[i_ele]
r2_ele_mod <- fit_results_df$r2[i_ele]

# Fit the original A=10 Gompertz for comparison
fit_ele_fixed <- fit_fixedA_gompertz(K = x_obs, p = y_obs)
c_ele         <- fit_ele_fixed$c
r2_ele_fixed  <- fit_ele_fixed$r2

# x-grid used for both models
x_max  <- max(x_obs, na.rm = TRUE)
x_grid <- seq(0, x_max, length.out = 2000)

# Shifted Gompertz is only defined for K > K_SHIFT
y_fit_mod  <- rep(NA_real_, length(x_grid))
idx_mod    <- x_grid > K_SHIFT
y_fit_mod[idx_mod] <- gompertz_shifted(x_grid[idx_mod], a_ele, b_ele, shift = K_SHIFT)

# Original Gompertz (A = 10)
y_fit_fixed <- exp(-10 * exp(-c_ele * x_grid))

# Data frames for plotting
df_ele_obs   <- tibble(K = x_obs,  p = y_obs)
df_ele_mod   <- tibble(K = x_grid, p = y_fit_mod)   %>% filter(is.finite(p))
df_ele_fixed <- tibble(K = x_grid, p = y_fit_fixed) %>% filter(is.finite(p))

# Nicely formatted R² labels
r2_lab_mod   <- paste0("R^2 = ", format(round(r2_ele_mod,   3), nsmall = 3))
r2_lab_fixed <- paste0("R^2 = ", format(round(r2_ele_fixed, 3), nsmall = 3))

# Left panel: shifted Gompertz
p_ele_mod <- ggplot(df_ele_obs, aes(K, p)) +
  geom_point(color = "grey35", alpha = 0.7, size = 1.8) +
  geom_line(data = df_ele_mod, aes(K, p), color = neutral_blue, linewidth = 1) +
  annotate(
    "label",
    x          = x_max,
    y          = 0.02,
    hjust      = 1,
    vjust      = 0,
    label      = r2_lab_mod,
    size       = 4.2,
    fontface   = "bold",
    label.size = 0.3,
    fill       = alpha("white", 0.95),
    color      = "grey10"
  ) +
  labs(
    title = "Modified Gompertz (shifted)",
    x     = "Starting population K",
    y     = "Persistence probability"
  ) +
  scale_x_continuous(
    limits = c(0, x_max),
    labels = scales::label_comma(),
    expand = expansion(mult = c(0, 0.02))
  ) +
  coord_cartesian(ylim = c(0, 1)) +
  theme_clean()

# Right panel: original A = 10 Gompertz
p_ele_fixed <- ggplot(df_ele_obs, aes(K, p)) +
  geom_point(color = "grey35", alpha = 0.7, size = 1.8) +
  geom_line(data = df_ele_fixed, aes(K, p), color = neutral_blue, linewidth = 1) +
  annotate(
    "label",
    x          = x_max,
    y          = 0.02,
    hjust      = 1,
    vjust      = 0,
    label      = r2_lab_fixed,
    size       = 4.2,
    fontface   = "bold",
    label.size = 0.3,
    fill       = alpha("white", 0.95),
    color      = "grey10"
  ) +
  labs(
    title = "Original Gompertz (A = 10)",
    x     = "Starting population K",
    y     = NULL
  ) +
  scale_x_continuous(
    limits = c(0, x_max),
    labels = scales::label_comma(),
    expand = expansion(mult = c(0, 0.02))
  ) +
  coord_cartesian(ylim = c(0, 1)) +
  theme_clean()

# Combine the two panels side by side
fig_gomp_elephant <- p_ele_mod + p_ele_fixed + plot_layout(widths = c(1, 1))
fig_gomp_elephant
# ggsave("Figures/gomp_elephant_side_by_side.png", fig_gomp_elephant, width = 9.2, height = 4.6, dpi = 300)
```

# 6. Figure 2 – Area-based curve and scaled derivative

```{r}
###############################################################################
# 6. Figure 2: Area-based modified Gompertz + scaled derivative
###############################################################################

# Use the elephant parameters (a_ele, b_ele) and link K to area via:
#   K = D_LOXODONTA * A
# So:
#   p(A) = exp( -a * (D*A - K_SHIFT)^(-b) ), for D*A > K_SHIFT

a_mod <- a_ele
b_mod <- b_ele

K_max       <- max(x_obs, na.rm = TRUE)
A_max       <- K_max / D_LOXODONTA       # maximum area corresponding to K_max
A_min_valid <- K_SHIFT / D_LOXODONTA     # minimum area where D*A crosses the shift

A_seq <- seq(0, A_max, length.out = 2000)
valid <- A_seq > A_min_valid

p_vals       <- rep(NA_real_, length(A_seq))
deriv_scaled <- rep(NA_real_, length(A_seq))

if (any(valid)) {
  K_valid <- D_LOXODONTA * A_seq[valid]
  z       <- K_valid - K_SHIFT

  # Persistence probability as a function of area
  p_valid <- exp(-a_mod * z^(-b_mod))
  p_vals[valid] <- p_valid

  # Derivative:
  #   dp/dK = a*b*(K - K_SHIFT)^(-b-1) * p(K)
  #   dK/dA = D_LOXODONTA
  dpdK <- a_mod * b_mod * z^(-b_mod - 1) * p_valid
  dpdA <- dpdK * D_LOXODONTA

  # Scale derivative so its maximum is 1 for plotting
  max_dpdA <- max(dpdA[is.finite(dpdA)], na.rm = TRUE)
  if (is.finite(max_dpdA) && max_dpdA > 0) {
    deriv_scaled[valid] <- dpdA / max_dpdA
  }
}

plot_df_area <- tibble(
  area         = A_seq,
  persistence  = p_vals,
  deriv_scaled = deriv_scaled
)

fig_gomp_area <- ggplot(plot_df_area, aes(x = area)) +
  geom_line(
    aes(y = persistence, colour = "Persistence probability"),
    linewidth = 1,
    na.rm = TRUE
  ) +
  geom_line(
    aes(y = deriv_scaled, colour = "Scaled derivative"),
    linewidth = 0.9,
    na.rm = TRUE
  ) +
  scale_color_manual(
    values = c(
      "Persistence probability" = "grey35",
      "Scaled derivative"       = neutral_blue
    ),
    labels = c(
      "Persistence probability",
      "dP/dA (scaled to max = 1)"
    ),
    name = NULL
  ) +
  scale_x_continuous(
    name   = expression("Area (km"^2*")"),
    limits = c(0, A_max),
    labels = label_comma(),
    expand = expansion(mult = c(0, 0.02))
  ) +
  scale_y_continuous(
    name   = "Persistence / scaled derivative",
    limits = c(0, 1.05),
    expand = expansion(mult = c(0, 0.02))
  ) +
  ggtitle("Area-based modified Gompertz") +
  theme_clean() +
  theme(
    plot.title      = element_text(hjust = 0.5),
    legend.position = "top",
    legend.margin   = margin(b = 2),
    legend.text     = element_text(size = 9)
  )

fig_gomp_area
# ggsave("Figures/gomp_area_derivative.png", fig_gomp_area, width = 7.5, height = 4.8, dpi = 300)
```

# 7. Figure 3 – All 31 curves, coloured by log10 mass

```{r}
###############################################################################
# 7. Figure 3: All 31 fitted curves – shared colourbar for log10(Mass)
###############################################################################

logM       <- log10(masses)
logM_range <- range(logM, na.rm = TRUE)

# Use K at p = 0.8 for fits #1 and #16 to define x-axis limits
K80_fit1  <- K_at_p(fit_results_df$a[1],  fit_results_df$b[1],  shift = K_SHIFT, p = 0.8)
K80_fit16 <- K_at_p(fit_results_df$a[16], fit_results_df$b[16], shift = K_SHIFT, p = 0.8)

x_min      <- K_SHIFT
x_to_large <- max(K80_fit1, K80_fit16)   # larger K range (left panel)
x_to_small <- min(K80_fit1, K80_fit16)   # smaller K range (right panel)

# Helper: build a tidy data frame of (K, p, logM) over a specified K range
build_curves_df <- function(x_from, x_to, n = 1500) {
  xg <- seq(x_from + 1e-6, x_to, length.out = n)

  map_dfr(seq_len(n_mass), function(j) {
    a_j <- fit_results_df$a[j]
    b_j <- fit_results_df$b[j]

    if (is.finite(a_j) && is.finite(b_j)) {
      tibble(
        idx  = j,
        K    = xg,
        p    = gompertz_shifted(xg, a_j, b_j, shift = K_SHIFT),
        logM = logM[j]
      )
    } else {
      NULL
    }
  }) %>%
    filter(is.finite(p))
}

df_curves_left  <- build_curves_df(x_from = x_min, x_to = x_to_large)
df_curves_right <- build_curves_df(x_from = x_min, x_to = x_to_small)

theme_curves <- function(base_size = 12) {
  theme_clean(base_size) +
    theme(
      plot.title  = element_text(face = "bold", size = base_size + 1),
      plot.margin = margin(8, 8, 8, 8)
    )
}

p_curves_left <- ggplot(df_curves_left, aes(K, p, group = idx, color = logM)) +
  geom_path(linewidth = 0.9, alpha = 0.95) +
  coord_cartesian(xlim = c(x_min, x_to_large), ylim = c(0, 1)) +
  labs(
    title = "Higher starting population range",
    x     = "Starting population K",
    y     = "Persistence probability",
    color = expression(log[10](Mass~"(g)"))
  ) +
  scale_color_viridis_c(limits = logM_range) +
  theme_curves()

p_curves_right <- ggplot(df_curves_right, aes(K, p, group = idx, color = logM)) +
  geom_path(linewidth = 0.9, alpha = 0.95) +
  coord_cartesian(xlim = c(x_min, x_to_small), ylim = c(0, 1)) +
  labs(
    title = "Lower starting population range",
    x     = "Starting population K",
    y     = NULL,
    color = expression(log[10](Mass~"(g)"))
  ) +
  scale_color_viridis_c(limits = logM_range) +
  theme_curves()

fig_gomp_overlays <- (p_curves_left + p_curves_right) +
  plot_layout(widths = c(1, 1), guides = "collect") &
  theme(
    legend.position    = "bottom",
    legend.title       = element_text(face = "bold"),
    legend.key.width   = unit(18, "pt"),
    legend.key.height  = unit(6, "pt")
  )

fig_gomp_overlays
# ggsave("Figures/gomp_overlays.png", fig_gomp_overlays, width = 10, height = 5.0, dpi = 300)
```

# 8. Figure 4 – LOESS smooths of Gompertz parameters vs mass

```{r}
###############################################################################
# 8. Figure 4: LOESS smooths for Gompertz parameters a and b
###############################################################################

theme_params <- function(base_size = 12) {
  theme_minimal(base_size = base_size) +
    theme(
      plot.title         = element_text(face = "bold", size = base_size + 2, margin = margin(b = 6)),
      axis.title         = element_text(face = "bold", size = base_size + 1),
      axis.text          = element_text(color = "grey20"),
      panel.grid.minor   = element_blank(),
      panel.grid.major.x = element_blank(),
      panel.grid.major.y = element_line(color = "grey90"),
      panel.border       = element_rect(color = "grey60", fill = NA, linewidth = 0.6),
      plot.margin        = margin(8, 8, 8, 8),
      legend.position    = "none"
    )
}

# Panel A: log10(a) vs log10(Mass)
fig_gomp_params_a <- ggplot(df_params, aes(x = logM, y = loga)) +
  geom_point(color = "grey35", alpha = 0.7, size = 1.9) +
  geom_smooth(
    method  = "loess",
    span    = 0.5,
    se      = TRUE,
    color   = neutral_blue,
    fill    = alpha(neutral_blue, 0.15),
    linewidth = 1.1
  ) +
  labs(
    title = "Gompertz parameter a",
    x     = expression(log[10](Mass~"(g)")),
    y     = expression(log[10](a))
  ) +
  theme_params()

# Panel B: b vs log10(Mass)
fig_gomp_params_b <- ggplot(df_params, aes(x = logM, y = b)) +
  geom_point(color = "grey35", alpha = 0.7, size = 1.9) +
  geom_smooth(
    method  = "loess",
    span    = 0.5,
    se      = TRUE,
    color   = neutral_blue,
    fill    = alpha(neutral_blue, 0.15),
    linewidth = 1.1
  ) +
  labs(
    title = "Gompertz parameter b",
    x     = expression(log[10](Mass~"(g)")),
    y     = "b"
  ) +
  theme_params()

fig_gomp_params <- fig_gomp_params_a + fig_gomp_params_b + plot_layout(widths = c(1, 1))
fig_gomp_params
# ggsave("Figures/gomp_loess_params.png", fig_gomp_params, width = 9.2, height = 4.6, dpi = 300)
```

# 9. Figure 5 – Envelope-only heatmaps

This final figure shows, for each K–p bin inside the envelope of all curves, the average log10(Mass) as a heatmap.

```{r}
###############################################################################
# 9. Figure 5: Envelope-only heatmaps (high resolution)
###############################################################################

logM_rng <- range(df_params$logM)

# Build regular tiles (K × p) only inside the envelope of all curves.
# For each K-bin:
#   1. Determine the min and max p-bin indices occupied.
#   2. Fill the vertical band between those with a logM value.
#   3. Fill internal gaps along p and K by carrying logM values up/down & left/right.
build_panel_tiles_envelope <- function(x_from, x_to,
                                       bins_x = 1000, bins_y = 300,
                                       n_mass_grid = 400, n_K = 2500) {

  # 1) Predict a(M), b(M) on a dense logM grid
  grid_logM <- seq(min(df_params$logM), max(df_params$logM),
                   length.out = n_mass_grid)

  a_pred <- 10^predict(loess_fit_a, newdata = data.frame(logM = grid_logM))
  b_pred <-      predict(loess_fit_b, newdata = data.frame(logM = grid_logM))

  ok <- is.finite(a_pred) & is.finite(b_pred)
  grid_logM <- grid_logM[ok]
  a_pred    <- a_pred[ok]
  b_pred    <- b_pred[ok]

  # 2) Predict p(K, logM) for a dense K grid
  K_seq <- seq(x_from + 1e-6, x_to, length.out = n_K)

  pred_df <- purrr::map_dfr(seq_along(grid_logM), function(i) {
    tibble(
      K    = K_seq,
      p    = gompertz_shifted(K_seq, a_pred[i], b_pred[i], shift = K_SHIFT),
      logM = grid_logM[i]
    )
  }) %>%
    filter(is.finite(p))

  # 3) Bin in K (x) and p (y)
  breaks_x <- seq(x_from, x_to, length.out = bins_x + 1)
  breaks_y <- seq(0,      1,    length.out = bins_y + 1)

  mids_x <- head(breaks_x, -1) + diff(breaks_x) / 2
  mids_y <- head(breaks_y, -1) + diff(breaks_y) / 2

  bw_x <- diff(breaks_x)[1]
  bw_y <- diff(breaks_y)[1]

  binned <- pred_df %>%
    mutate(
      i = cut(K, breaks_x, labels = FALSE, include.lowest = TRUE),
      j = cut(p, breaks_y, labels = FALSE, include.lowest = TRUE)
    ) %>%
    drop_na(i, j)

  # 4) For each K-bin i, find vertical envelope j_min..j_max
  env <- binned %>%
    group_by(i) %>%
    summarise(
      j_min = min(j),
      j_max = max(j),
      .groups = "drop"
    )

  # Mean logM in each occupied tile (i,j)
  means <- binned %>%
    group_by(i, j) %>%
    summarise(
      fill_val = mean(logM),
      .groups  = "drop"
    )

  # 5) Create full tile grid inside the envelope and fill any gaps
  grid_in_env <- env %>%
    rowwise() %>%
    mutate(j = list(seq.int(j_min, j_max))) %>%
    unnest(j) %>%
    ungroup() %>%
    dplyr::select(i, j)

  tiles <- grid_in_env %>%
    left_join(means, by = c("i", "j")) %>%
    arrange(i, j) %>%
    group_by(i) %>% tidyr::fill(fill_val, .direction = "downup") %>%
    ungroup() %>%
    arrange(j, i) %>%
    group_by(j) %>% tidyr::fill(fill_val, .direction = "downup") %>%
    ungroup()

  # 6) Map bin indices back to K and p coordinates for geom_tile()
  tiles %>%
    transmute(
      Kc       = mids_x[i],
      Pc       = mids_y[j],
      fill_val = fill_val,
      tile_w   = bw_x,
      tile_h   = bw_y
    )
}

# Use the same K ranges as in Figure 3
x_min      <- K_SHIFT
heat_left  <- build_panel_tiles_envelope(x_from = x_min, x_to = x_to_large)
heat_right <- build_panel_tiles_envelope(x_from = x_min, x_to = x_to_small)

theme_heat <- function(base_size = 12) {
  theme_minimal(base_size = base_size) +
    theme(
      plot.title         = element_text(face = "bold", size = base_size + 1, margin = margin(b = 6)),
      axis.title         = element_text(face = "bold"),
      axis.text          = element_text(color = "grey20"),
      panel.grid.minor   = element_blank(),
      panel.grid.major.x = element_blank(),
      panel.grid.major.y = element_line(color = "grey90"),
      panel.border       = element_rect(color = "grey60", fill = NA, linewidth = 0.6),
      plot.margin        = margin(8, 8, 8, 8)
    )
}

p_heat_left <- ggplot(heat_left, aes(x = Kc, y = Pc, fill = fill_val)) +
  geom_tile(aes(width = tile_w, height = tile_h), colour = NA) +
  coord_cartesian(xlim = c(x_min, x_to_large), ylim = c(0, 1), expand = FALSE) +
  labs(
    title = "Higher starting population range",
    x     = "Starting population K",
    y     = "Persistence probability",
    fill  = expression(log[10](Mass~"(g)"))
  ) +
  scale_fill_viridis_c(limits = logM_rng) +
  theme_heat()

p_heat_right <- ggplot(heat_right, aes(x = Kc, y = Pc, fill = fill_val)) +
  geom_tile(aes(width = tile_w, height = tile_h), colour = NA) +
  coord_cartesian(xlim = c(x_min, x_to_small), ylim = c(0, 1), expand = FALSE) +
  labs(
    title = "Lower starting population range",
    x     = "Starting population K",
    y     = NULL,
    fill  = expression(log[10](Mass~"(g)"))
  ) +
  scale_fill_viridis_c(limits = logM_rng) +
  theme_heat()

fig_gomp_heat <- (p_heat_left + p_heat_right) +
  plot_layout(widths = c(1, 1), guides = "collect") &
  theme(
    legend.position   = "bottom",
    legend.title      = element_text(face = "bold"),
    legend.key.width  = unit(18, "pt"),
    legend.key.height = unit(6, "pt")
  )

fig_gomp_heat
# ggsave("Figures/gomp_heatmaps_hi_res.png", fig_gomp_heat, width = 11, height = 5.8, dpi = 350)
```