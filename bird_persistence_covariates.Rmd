---
title: "bird_persistence_covariates"
output: html_document
---

```{r}
###############################################################################
# 0. Packages and paths
###############################################################################

# Core data wrangling
library(dplyr)
library(tidyr)
library(purrr)
library(readr)
library(stringr)

# IUCN Red List API (requires REDLIST_API_KEY in your environment)
library(rredlist)

# ---------------------------------------------------------------------------
# Centralized file paths
# ---------------------------------------------------------------------------

PATHS <- list(
  # Raw inputs
  birds_summary   = "Data/Raw/bird_summary.csv",      # IUCN-based spatial summary
  bird_weights    = "Data/Raw/bird_data.txt",         # body mass + traits
  iucn_synonyms   = "Data/Raw/bird_synonyms.csv",     # mapping between name variants
  random_effects  = "Data/Raw/random_effects.csv",    # Santini et al. (2018) random effects

  # Gompertz LOESS fits (diet-specific, stored as a named list by combo string)
  bird_loess_fits = "Data/Clean/bird_loess_fits.rds",

  # Final output
  out_bird_data   = "Data/Clean/bird_data.csv"
)
```

# 1. Helper functions for taxon strings and IUCN codes

```{r}
###############################################################################
# 1. Helper functions
###############################################################################

# ---------------------------------------------------------------------------
# 1.1 Standardise taxon strings for consistent joins
# ---------------------------------------------------------------------------
#
# Many sources differ only in whitespace / capitalisation, so we:
#   - trim extra spaces,
#   - collapse multiple spaces to one,
#   - convert to lowercase.
clean_taxon <- function(x) {
  x %>%
    str_squish() %>%  # collapse internal whitespace + trim
    tolower()
}

# ---------------------------------------------------------------------------
# 1.2 Normalise IUCN habitat codes like "14_4_1" → "14.4.1"
# ---------------------------------------------------------------------------
normalize_codes <- function(x) {
  x %>%
    as.character() %>%
    trimws() %>%
    gsub("_", ".", ., fixed = TRUE)
}

# ---------------------------------------------------------------------------
# 1.3 Group IUCN 14.x (Artificial - Terrestrial) into broad habitat classes
# ---------------------------------------------------------------------------
#
# Input:
#   hab_codes: character vector of IUCN habitat codes (e.g. "14.1", "14.4.1")
#
# Output:
#   character vector of broad artificial-terrestrial categories such as:
#     - "Arable & Pastureland"
#     - "Plantations & Heavily Degraded Former Forest"
#     - "Urban & Rural Gardens"
summarize_artificial_terrestrial <- function(hab_codes) {
  # If there are no codes at all, return empty vector (no artificial habitats)
  if (length(hab_codes) == 0) return(character(0))

  # Normalise codes and keep only those in the 14.x group
  codes    <- normalize_codes(hab_codes)
  at_codes <- codes[str_detect(codes, "^14(\\.|$)")]
  if (!length(at_codes)) return(character(0))

  # Pull out the Level-2 part (e.g. "14.1", "14.4" → 1, 4, etc.)
  lvl2_chr <- str_match(at_codes, "^14\\.(\\d+)")[, 2]
  lvl2     <- unique(suppressWarnings(as.integer(lvl2_chr)))
  lvl2     <- lvl2[!is.na(lvl2)]

  # Map groups of Level-2 codes to broad classes
  groups <- character(0)
  if (any(lvl2 %in% c(1, 2))) groups <- c(groups, "Arable & Pastureland")                        # 14.1 + 14.2
  if (any(lvl2 %in% c(3, 6))) groups <- c(groups, "Plantations & Heavily Degraded Former Forest") # 14.3 + 14.6
  if (any(lvl2 %in% c(4, 5))) groups <- c(groups, "Urban & Rural Gardens")                        # 14.4 + 14.5

  unique(groups)
}
```

# 2. Load birds, reconcile names, and attach body mass / traits

```{r}
###############################################################################
# 2. Load birds, weights, and synonyms; resolve names; attach masses
###############################################################################

# ---------------------------------------------------------------------------
# 2.1 Load base tables
# ---------------------------------------------------------------------------
#
# t_birds        : IUCN spatial summary table (per-species range / area info)
# bird_weights   : body mass and other traits (EltonTraits-style)
# iucn_synonyms  : mapping between IUCN names and alternative scientific names
t_birds        <- read_csv(PATHS$birds_summary, show_col_types = FALSE)
bird_weights   <- read_tsv(PATHS$bird_weights,  show_col_types = FALSE)
iucn_synonyms  <- read_csv(PATHS$iucn_synonyms, show_col_types = FALSE)

# bird_weights came from a format where hyphens are used; R converts them to
# dots by default, so we normalise explicitly to avoid surprises.
names(bird_weights) <- gsub("-", ".", names(bird_weights))

# ---------------------------------------------------------------------------
# 2.2 Clean taxonomic keys (lowercase, trimmed) for consistent joins
# ---------------------------------------------------------------------------

t_birds <- t_birds %>%
  mutate(scientificName = clean_taxon(scientificName))

iucn_synonyms <- iucn_synonyms %>%
  mutate(
    scientificName = clean_taxon(scientificName),
    candidate      = clean_taxon(paste(genusName, speciesName))
  )

bird_weights <- bird_weights %>%
  mutate(Scientific = clean_taxon(Scientific))

# ---------------------------------------------------------------------------
# 2.3 Keep only synonym candidates that actually exist in bird_weights
# ---------------------------------------------------------------------------
#
# For each IUCN scientificName:
#   - keep at most one candidate that appears in bird_weights$Scientific,
#   - this creates a compact mapping scientificName → candidate.
valid_synonyms <- iucn_synonyms %>%
  semi_join(bird_weights, by = c("candidate" = "Scientific")) %>%
  group_by(scientificName) %>%
  slice(1) %>%   # if multiple candidates exist, pick the first
  ungroup() %>%
  dplyr::select(scientificName, candidate)

# ---------------------------------------------------------------------------
# 2.4 Resolve scientific names and attach trait / mass data
# ---------------------------------------------------------------------------
#
# For each row in t_birds:
#   - if its scientificName exists in bird_weights$Scientific, use that;
#   - otherwise, use the candidate synonym (if available);
#   - then join bird_weights on the resolved name and rebuild grouped diets.

birds <- t_birds %>%
  left_join(valid_synonyms, by = "scientificName") %>%
  mutate(
    scientific_resolved = if_else(
      scientificName %in% bird_weights$Scientific,
      scientificName,
      coalesce(candidate, scientificName)   # fallback: original IUCN name
    )
  ) %>%
  left_join(
    bird_weights,
    by = c("scientific_resolved" = "Scientific")
  ) %>%
  # Rebuild grouped diet compositions (all values still in percent, 0–100)
  mutate(
    # All vertebrate-based resources (including scavenging and unknown vertebrates)
    Diet.VertFishScav = Diet.Vend + Diet.Vect + Diet.Vfish + Diet.Vunk + Diet.Scav,
    # Fruit + nectar (reproductive parts and floral resources)
    Diet.FruiNect     = Diet.Fruit + Diet.Nect,
    # Other plant material + seeds
    Diet.PlantSeed    = Diet.PlantO + Diet.Seed,
    # All plant-based foods
    Diet.AllPlants    = Diet.FruiNect + Diet.PlantSeed
    # Diet.Inv is already present from bird_weights (after hyphen→dot renaming)
  )
```

# 3. Random effects from Santini et al. and density model

```{r}
###############################################################################
# 3. Random effects (Order / Family / Species) and density estimates
###############################################################################

# ---------------------------------------------------------------------------
# 3.1 Load and attach random effects
# ---------------------------------------------------------------------------
#
# random_effects gives taxonomic random effects for log10 density, with:
#   - Effect_Order, Effect_Family, Effect_Species
# We:
#   - keep only Aves,
#   - clean taxon names,
#   - join by orderName, familyName, and resolved scientific name,
#   - replace missing effects with zero (no random deviation).
random_effects <- read_csv(PATHS$random_effects, show_col_types = FALSE) %>%
  filter(Class == "Aves") %>%
  mutate(
    Order   = clean_taxon(Order),
    Family  = clean_taxon(Family),
    Species = clean_taxon(Species)
  )

birds <- birds %>%
  mutate(
    orderName  = clean_taxon(orderName),
    familyName = clean_taxon(familyName)
  ) %>%
  # Attach order-level effect
  left_join(
    random_effects %>% distinct(Order, Effect_Order),
    by = c("orderName" = "Order")
  ) %>%
  # Attach family-level effect
  left_join(
    random_effects %>% distinct(Family, Effect_Family),
    by = c("familyName" = "Family")
  ) %>%
  # Attach species-level effect (aligned with scientific_resolved)
  left_join(
    random_effects %>% distinct(Species, Effect_Species),
    by = c("scientific_resolved" = "Species")
  ) %>%
  mutate(
    Effect_Order   = replace_na(Effect_Order,   0),
    Effect_Family  = replace_na(Effect_Family,  0),
    Effect_Species = replace_na(Effect_Species, 0)
  )

# ---------------------------------------------------------------------------
# 3.2 Log10-density model coefficients (bird-specific, Diet.5Cat)
# ---------------------------------------------------------------------------
#
# Model:
#   log10(density) =
#     B0 + Effect_Order + Effect_Family + Effect_Species +
#     effect_diet + B_mass * log10(BodyMass.Value)
#
# where effect_diet depends on Diet.5Cat (VertFishScav as reference).
B0     <-  1.30947404816817
B_mass <- -0.341277579477041

# ---------------------------------------------------------------------------
# 3.3 Predict log10 density and density (ind / km²)
# ---------------------------------------------------------------------------

birds <- birds %>%
  mutate(
    # Diet effect (5-category; VertFishScav is reference with effect 0)
    effect_diet = case_when(
      Diet.5Cat == "FruiNect"     ~ 0.42760614375972505,
      Diet.5Cat == "Invertebrate" ~ 0.181241393478166,
      Diet.5Cat == "Omnivore"     ~ 0.28471583669890205,
      Diet.5Cat == "PlantSeed"    ~ 0.34312864063468,
      Diet.5Cat == "VertFishScav" ~ 0,
      TRUE                        ~ NA_real_
    ),

    # Mass effect (BodyMass.Value in grams; guard against non-positive mass)
    effect_mass = B_mass * if_else(BodyMass.Value > 0, log10(BodyMass.Value), NA_real_),

    # Predict log10 density (only where mass effect is finite)
    log10_density = if_else(
      is.finite(effect_mass),
      B0 + Effect_Order + Effect_Family + Effect_Species + effect_diet + effect_mass,
      NA_real_
    ),

    # Back-transform to density (individuals per km²)
    density = 10^log10_density
  )
```

# 4. Home range, dispersal distance, and minimum patch sizes

```{r}
###############################################################################
# 4. Home range, dispersal distance, minimum patch sizes
###############################################################################

# Using body mass, diet category, and density, we derive:
#   - home_range_size (km²),
#   - dispersal_dist (km),
#   - min_patch_size (km²) for ~10 individuals,
#   - min_patch_size500 (km²) for ~500 individuals.
#
# Home range scaling:
#   VertFishScav : HR ≈ 21 * M^1.13   (M in kg)
#   others       : HR ≈ 3.7 * M       (M in kg)
birds <- birds %>%
  mutate(
    # Convert body mass from grams to kilograms
    body_mass_kg = BodyMass.Value / 1000,

    # Diet-specific home range scaling (area in km²)
    home_range_size = if_else(
      Diet.5Cat == "VertFishScav",
      21 * body_mass_kg^1.13,
      3.7 * body_mass_kg
    ),

    # Dispersal distance as a function of home range (km)
    dispersal_dist = 12 * sqrt(home_range_size),

    # Minimum patch areas that can hold ~10 and ~500 individuals
    min_patch_size    = 10  / density,
    min_patch_size500 = 500 / density
  )
```

# 5. IUCN habitats: Level-1 and grouped artificial terrestrial categories

```{r}
###############################################################################
# 5. IUCN habitats → Level-1 classes and grouped 14.x categories
###############################################################################

# ---------------------------------------------------------------------------
# 5.1 Lookup: IUCN Level-1 code → descriptive label
# ---------------------------------------------------------------------------

level1_lookup <- c(
  `1`  = "Forest",
  `2`  = "Savanna",
  `3`  = "Shrubland",
  `4`  = "Grassland",
  `5`  = "Wetlands (inland)",
  `6`  = "Rocky Areas",
  `7`  = "Caves & Subterranean (non-aquatic)",
  `8`  = "Desert",
  `9`  = "Marine Neritic",
  `10` = "Marine Oceanic",
  `11` = "Marine Deep Ocean Floor",
  `12` = "Marine Intertidal",
  `13` = "Marine Coastal/Supratidal",
  `14` = "Artificial - Terrestrial",
  `15` = "Artificial - Aquatic",
  `16` = "Introduced Vegetation",
  `17` = "Other",
  `18` = "Unknown"
)

# ---------------------------------------------------------------------------
# 5.2 Helper: get habitats for one taxon via IUCN API
# ---------------------------------------------------------------------------
#
# For a given (genus, species):
#   - call rl_species_latest() to get latest species-level assessment,
#   - keep only habitats with suitability == "suitable",
#   - map codes to:
#       * level1_habitats : full Level-1 labels (including 14),
#       * habitats_mixed  : Level-1 labels excluding 14 +
#                           broad artificial-terrestrial categories for 14.x.
#
# Returns a tibble with one row and two character columns.
get_habitats_one <- function(genus, species) {
  # Safely call IUCN API (NULL on failure instead of crashing)
  res <- purrr::possibly(
    rl_species_latest,
    otherwise = NULL
  )(genus = trimws(genus), species = trimws(species), scope = "1", parse = TRUE)

  # If no data or no habitats, return NA placeholders
  if (is.null(res) || is.null(res$habitats) || nrow(res$habitats) == 0) {
    return(tibble(
      level1_habitats = NA_character_,
      habitats_mixed  = NA_character_
    ))
  }

  # Keep only habitats marked as "suitable"
  hab <- res$habitats %>%
    mutate(suitability = tolower(trimws(as.character(suitability)))) %>%
    filter(suitability == "suitable")

  if (nrow(hab) == 0) {
    return(tibble(
      level1_habitats = NA_character_,
      habitats_mixed  = NA_character_
    ))
  }

  # Normalise codes (e.g. "14_4_1" → "14.4.1")
  codes <- normalize_codes(hab$code)

  # Extract Level-1 numeric codes from the start of each code
  lvl1_codes <- suppressWarnings(as.integer(str_extract(codes, "^\\d+")))
  lvl1_codes <- lvl1_codes[!is.na(lvl1_codes)]

  # All Level-1 names (including 14)
  lvl1_names <- unique(unname(level1_lookup[as.character(lvl1_codes)]))
  lvl1_str   <- if (length(lvl1_names)) paste(lvl1_names, collapse = ", ") else NA_character_

  # "Mixed" summary:
  #   - Level-1 names excluding 14 ("Artificial - Terrestrial"),
  #   - plus grouped 14.x categories via summarize_artificial_terrestrial().
  lvl1_except14 <- unique(unname(level1_lookup[as.character(lvl1_codes[lvl1_codes != 14])]))
  lvl1_except14 <- lvl1_except14[!is.na(lvl1_except14)]

  grouped_14 <- summarize_artificial_terrestrial(codes)

  mixed_vec <- unique(c(lvl1_except14, grouped_14))
  mixed_str <- if (length(mixed_vec)) paste(mixed_vec, collapse = ", ") else NA_character_

  tibble(
    level1_habitats = lvl1_str,
    habitats_mixed  = mixed_str
  )
}

# ---------------------------------------------------------------------------
# 5.3 Query IUCN once per unique (genus, species) pair and join back
# ---------------------------------------------------------------------------
#
# We:
#   - extract unique genusName + speciesName pairs from birds,
#   - call get_habitats_one() for each,
#   - attach level1_habitats and habitats_mixed to the main birds table.

# Unique species for IUCN API calls
species_tbl <- birds %>%
  distinct(genusName, speciesName) %>%
  filter(!is.na(genusName), !is.na(speciesName))

# For each species, fetch its habitats and unpack the small tibble
hab_map <- species_tbl %>%
  mutate(hab = map2(genusName, speciesName, get_habitats_one)) %>%
  unnest_wider(hab)

# Join habitat summaries back to the per-species birds table
birds <- birds %>%
  left_join(hab_map, by = c("genusName", "speciesName"))
```

# 6. Gompertz parameters per species from LOESS fits

```{r}
###############################################################################
# 6. Gompertz parameters per species (a_pred, b_pred)
###############################################################################

# Rebuild grouped diet compositions needed for ILR-based Gompertz fits.
# All diet columns are in percent (0–100).
birds <- birds %>%
  mutate(
    # All vertebrate-based resources (including scavenging and unknown vertebrates)
    Diet_VertFishScav = Diet.Vend + Diet.Vect + Diet.Vfish + Diet.Vunk + Diet.Scav,
    # Fruit + nectar (reproductive parts and floral resources)
    Diet_FruiNect     = Diet.Fruit + Diet.Nect,
    # Other plant material + seeds
    Diet_PlantSeed    = Diet.PlantO + Diet.Seed,
    # All animal-based foods (vertebrates + invertebrates)
    Diet_AllAnimals   = Diet_VertFishScav + Diet.Inv,
    # All plant-based foods
    Diet_AllPlants    = Diet_FruiNect + Diet_PlantSeed
  )

# Load diet-specific LOESS models from the Gompertz-fitting script.
#   bird_loess_fits is a named list:
#     - names(bird_loess_fits): diet combos as "Inv_AllPlants_VertFishScav" strings
#     - each element: list(loess_a = <loess>, loess_b = <loess>)
bird_loess_fits <- readRDS(PATHS$bird_loess_fits)

# Build ILR-order diet combination string per species and log-mass predictor:
#   combo = "Diet.Inv_Diet.AllPlants_Diet_VertFishScav" in integer %.
# Only species whose combo matches one of names(bird_loess_fits) receive
# non-NA Gompertz parameters; others remain NA.
birds <- birds %>%
  mutate(
    diet_combo = sprintf(
      "%d_%d_%d",
      round(Diet.Inv),
      round(Diet_AllPlants),
      round(Diet_VertFishScav)
    ),
    mass_log10 = if_else(BodyMass.Value > 0, log10(BodyMass.Value), NA_real_),
    a_pred     = NA_real_,
    b_pred     = NA_real_
  )

# For each diet combination with fitted LOESS models, predict a_pred and b_pred
for (cmb in names(bird_loess_fits)) {
  idx <- which(birds$diet_combo == cmb & is.finite(birds$mass_log10))
  if (!length(idx)) next

  fits    <- bird_loess_fits[[cmb]]
  loess_a <- fits$loess_a
  loess_b <- fits$loess_b

  a_vals <- 10 ^ predict(loess_a, newdata = data.frame(logM = birds$mass_log10[idx]))
  b_vals <-      predict(loess_b, newdata = data.frame(logM = birds$mass_log10[idx]))

  birds$a_pred[idx] <- as.numeric(a_vals)
  birds$b_pred[idx] <- as.numeric(b_vals)
}
```

# 7. Final export

```{r}
###############################################################################
# 7. Final export
###############################################################################

# The final table "birds" now contains:
#   - Spatial info + IUCN IDs,
#   - Resolved scientific names and traits (mass, diet),
#   - Diet.5Cat and grouped diet compositions (Diet.Inv, Diet_AllPlants,
#     Diet_VertFishScav, etc.),
#   - Random effects and predicted density,
#   - Home range, dispersal distance, minimum patch sizes,
#   - IUCN habitat summaries (level1_habitats, habitats_mixed),
#   - Gompertz parameters (a_pred, b_pred) for persistence curves,
#     filled only for species whose diet compositions exactly match one of the
#     ILR diet combinations used in the Gompertz fits.
write_csv(birds, PATHS$out_bird_data)
```