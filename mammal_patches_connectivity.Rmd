---
title: "mammal_patches_connectivity"
output: html_document
---

```{r}
###############################################################################
# Mammal patches + connectivity builder
# - Builds habitat masks (once)
# - Aligns presence rasters to a common grid
# - For each species:
#     * Builds suitability = habitat ∩ presence
#     * Identifies patches, filters by min_patch_size
#     * Groups patches into population units via dispersal distance
#     * Filters populations by min_patch_size500
#     * Reindexes final patches and writes patch rasters
#     * Records patch areas + PU IDs in a lookup table
#     * Builds sparse connectivity within each PU
# - Saves:
#     * Spatial/Patches/<species>.tif           (final patch rasters)
#     * Spatial/all_patch_lookup.rds           (patch → PU + area)
#     * Spatial/all_connectivity.rds           (PU-wise adjacency)
###############################################################################

library(terra)
library(sf)
library(igraph)
library(dplyr)
library(fasterRaster)

# Suggested to run once per session
sf::sf_use_s2(TRUE)

# Simple log helper ----------------------------------------------------------
log_step <- function(spp, msg) {
  message(sprintf("[%s] [%s] %s",
                  format(Sys.time(), "%Y-%m-%d %H:%M:%S"),
                  spp, msg))
}
```

```{r}
###############################################################################
# 1. Build habitat masks from land cover (run once to create Spatial/masks.tif)
###############################################################################

# Minimal builder: each layer is 1 = habitat present, NA = otherwise
build_habitat_masks_from_lc <- function(lc_roi, class_map) {
  terra::rast(lapply(names(class_map), function(nm) {
    codes <- class_map[[nm]]
    r <- if (length(codes) == 0 || all(is.na(codes))) {
      lc_roi[[1]] * NA_integer_           # all-NA layer with same grid
    } else {
      terra::ifel(lc_roi %in% codes, 1L, NA_integer_)
    }
    names(r) <- nm
    r
  }))
}

# Land-cover class → broad habitat layer mapping
class_map <- list(
  forest = c(50L, 60L, 61L, 62L, 70L, 71L, 72L, 90L, 160L),
  savanna = c(120L, 121L, 122L),
  shrubland = c(120L, 121L, 122L, 150L, 151L, 152L, 153L, 200L, 201L, 202L),
  grassland = c(130L, 140L, 150L, 151L, 152L, 153L),
  wetlands = c(20L, 80L, 81L, 82L, 160L, 170L, 180L, 210L),
  rocky_areas = c(70L, 71L, 72L, 130L, 150L, 151L, 152L, 153L, 200L, 201L, 202L),
  desert = c(150L, 151L, 152L, 153L, 200L, 201L, 202L),
  artificial_arable_pasture = c(11L, 20L, 190L),
  artificial_degraded_forest_plantation = integer(0),
  artificial_urban_rural_gardens = c(190L),
  artificial_aquatic = c(20L, 160L, 170L, 180L, 190L, 210L)
)

# One-time build of habitat masks (comment out after first run if masks exist)
if (!file.exists("Spatial/masks.tif")) {
  lc  <- terra::rast("Spatial/esacci_2022_pfts.tif")
  roi <- terra::ext(43.18, 50.56, -25.64, -11.89)   # Madagascar ROI
  lc_roi <- terra::crop(lc, roi)

  masks <- build_habitat_masks_from_lc(lc_roi, class_map)

  terra::writeRaster(
    masks, filename = "Spatial/masks.tif", overwrite = TRUE,
    wopt = list(
      datatype = "INT1U",
      gdal     = c("TILED=YES", "BLOCKXSIZE=512", "BLOCKYSIZE=512",
                   "COMPRESS=LZW", "BIGTIFF=IF_SAFER")
    )
  )
}
```

```{r}
###############################################################################
# 2. Load species table and (optionally) filter focal species
###############################################################################

species_df <- read.csv("Data/Clean/mammal_data.csv", stringsAsFactors = FALSE)

# Optional: restrict to a focal set of species (Madagascar example)
target_species <- c(
  "cheirogaleus major", "cheirogaleus medius", "cryptoprocta ferox",
  "echinops telfairi", "eliurus majori", "eliurus minor",
  "eliurus myoxinus", "eliurus tanala", "eliurus webbi",
  "eulemur albifrons", "eulemur coronatus", "eulemur fulvus",
  "eulemur rubriventer", "eulemur rufus", "fossa fossana",
  "galidia elegans", "gymnuromys roberti", "hapalemur griseus",
  "hemicentetes semispinosus", "indri indri", "lepilemur edwardsi",
  "lepilemur leucopus", "lepilemur mustelinus", "lepilemur ruficaudatus",
  "microcebus murinus", "microcebus rufus", "microgale brevicaudata",
  "microgale cowani", "microgale gymnorhyncha", "microgale longicaudata",
  "microgale parvula", "microgale principula", "microgale soricoides",
  "microgale taiva", "nesomys rufus", "oryzorictes hova", "setifer setosus",
  "tenrec ecaudatus", "varecia variegata"
)

species_df <- species_df %>%
  dplyr::filter(scientific_resolved %in% target_species) %>%
  mutate(scientific_resolved = gsub(" ", "_", scientific_resolved))
```

```{r}
###############################################################################
# 3. Build presence rasters aligned to habitat mask template
###############################################################################

# Template grid from habitat masks (resolution / CRS / extent)
masks    <- terra::rast("Spatial/masks.tif")
template <- masks[[1]]
valid_mask_layers <- names(masks)

# Presence rasters: files in Spatial/mammal_ppm_bin, names → lower + no "_bin"
tif_files <- list.files("Spatial/mammal_ppm_bin", pattern = "\\.tif$", full.names = TRUE)
tif_names <- tools::file_path_sans_ext(basename(tif_files))
tif_names <- tolower(sub("_bin$", "", tif_names))

resolved <- tolower(trimws(species_df$scientific_resolved))
resolved <- resolved[!is.na(resolved) & nzchar(resolved)]

keep <- tif_names %in% resolved
tif_names <- tif_names[keep]
tif_files <- tif_files[keep]

# Reproject each presence raster to the template grid (1/NA, aligned)
pres_rasters <- setNames(vector("list", length(tif_files)), tif_names)
for (k in seq_along(tif_files)) {
  r0 <- terra::rast(tif_files[k])                         # native CRS / res
  r1 <- terra::project(r0, y = template, method = "near") # align to template
  pres_rasters[[k]] <- r1
}
```

```{r}
###############################################################################
# 4. Initialize fasterRaster / GRASS backend
###############################################################################

# Point this to your local GRASS installation
faster(grassDir = "C:/Program Files/GRASS GIS 8.4")
```

```{r}
###############################################################################
# 5. Per-species pipeline: suitability → patches → PUs → connectivity
###############################################################################

# IUCN habitat label → mask layer name in "masks"
habitat_map <- c(
  "Forest" = "forest",
  "Savanna" = "savanna",
  "Shrubland" = "shrubland",
  "Grassland" = "grassland",
  "Wetlands (inland)" = "wetlands",
  "Rocky Areas (e.g., inland cliffs, mountain peaks)" = "rocky_areas",
  "Desert" = "desert",
  "Arable & Pastureland" = "artificial_arable_pasture",
  "Plantations & Heavily Degraded Former Forest" = "artificial_degraded_forest_plantation",
  "Urban & Rural Gardens" = "artificial_urban_rural_gardens",
  "Artificial - Aquatic" = "artificial_aquatic"
)

# Accumulators: patch lookup table + connectivity list
all_patch_lookup <- data.frame(
  species        = character(),
  patch_id       = integer(),
  pu_id          = integer(),
  patch_area_km2 = numeric(),
  stringsAsFactors = FALSE
)

all_connectivity <- list()

for (i in seq_len(nrow(species_df))) {

  sci <- species_df$scientific_resolved[i]
  log_step(sci, "START")

  #### 5.1 Suitability raster: habitat ∩ presence ---------------------------
  log_step(sci, "SUITABILITY")

  # Parse IUCN habitat labels for this species
  hraw <- species_df$habitats_mixed[i]
  lbls <- if (is.na(hraw)) character(0) else trimws(strsplit(hraw, ",")[[1]])

  # Map to mask layer names, drop unknown / missing / non-existent layers
  mask_names <- unname(habitat_map[lbls])
  mask_names <- mask_names[!is.na(mask_names)]
  mask_names <- unique(mask_names[mask_names %in% valid_mask_layers])

  if (length(mask_names) == 0L) {
    log_step(sci, "NO_VALID_HABITAT → SKIP")
    next
  }

  # Union of all habitat layers (1 where any habitat present, NA otherwise)
  hab_union <- if (length(mask_names) == 1L) {
    masks[[mask_names]]
  } else {
    u <- terra::app(masks[[mask_names]], fun = sum, na.rm = TRUE)
    terra::ifel(u > 0, 1L, NA_integer_)
  }

  # Presence raster aligned to template (1 inside predicted presence, NA elsewhere)
  pres <- pres_rasters[[sci]]
  if (is.null(pres)) {
    log_step(sci, "NO_PRESENCE_RASTER → SKIP")
    next
  }

  # Suitability: presence restricted to suitable habitat (1/NA)
  suit <- hab_union * pres

  #### 5.2 Patches: clumps + min_patch_size filter -------------------------
  log_step(sci, "PATCHES")

  # Trim zero-edges for faster processing
  suit_trim <- terra::trim(suit)

  # Connected-component labels (4-neighbourhood)
  cl_fast <- fasterRaster::clump(fasterRaster::fast(suit_trim), diagonal = FALSE)
  cl_spat <- terra::rast(cl_fast)

  # Patch areas (km²) = sum of cell areas per clump ID
  cell_area_km <- terra::cellSize(suit_trim, unit = "km")
  area_tab <- as.data.frame(terra::zonal(cell_area_km, cl_spat, "sum", na.rm = TRUE))
  names(area_tab) <- c("old_id", "area_km2")

  # Keep only patches ≥ species-specific min_patch_size
  keep_old <- area_tab$old_id[area_tab$area_km2 >= species_df$min_patch_size[i]]
  if (!length(keep_old)) {
    log_step(sci, "NO_PATCHES_GE_min_patch_size → SKIP")
    next
  }

  # Reindex kept patches to 1..n, then extend back to full extent
  kept_ids_trim <- terra::classify(
    cl_spat,
    rcl    = cbind(as.integer(keep_old), seq_along(keep_old)),
    others = NA_integer_
  )
  kept_ids_full <- terra::extend(kept_ids_trim, suit)

  # Patch table with areas
  patches_tab <- data.frame(
    patch_id       = seq_along(keep_old),
    patch_area_km2 = area_tab$area_km2[match(keep_old, area_tab$old_id)]
  )

  #### 5.3 Populations (PUs) via dispersal distance -------------------------
  log_step(sci, "POPULATIONS")

  # Polygons per patch (dissolved by patch_id)
  patches_sf <- sf::st_as_sf(
    terra::as.polygons(kept_ids_full, values = TRUE, dissolve = TRUE)
  )

  patch_col <- setdiff(names(patches_sf), attr(patches_sf, "sf_column"))[1]
  patches_sf$patch_id <- as.integer(patches_sf[[patch_col]])
  patches_sf <- patches_sf[!is.na(patches_sf$patch_id), ]

  # Neighbourhood within species-specific dispersal distance (meters)
  nb <- sf::st_is_within_distance(
    patches_sf,
    patches_sf,
    dist = species_df$dispersal_dist[i] * 1000
  )

  g <- igraph::graph_from_adj_list(nb, mode = "out") |>
    igraph::as_undirected("collapse") |>
    igraph::simplify(remove.multiple = TRUE, remove.loops = TRUE)

  comp <- igraph::components(g)$membership
  patches_sf$pu_id_unfiltered <- as.integer(match(comp, sort(unique(comp))))

  patch_to_pop <- data.frame(
    patch_id         = patches_sf$patch_id,
    pu_id_unfiltered = patches_sf$pu_id_unfiltered
  )

  #### 5.4 Population filter (min_patch_size500) ----------------------------
  log_step(sci, "POP_FILTER")

  # Total area per provisional PU
  patch_area_df <- merge(
    patches_tab[, c("patch_id", "patch_area_km2")],
    patch_to_pop,
    by = "patch_id"
  )

  pop_area_df <- aggregate(
    patch_area_km2 ~ pu_id_unfiltered,
    patch_area_df,
    sum,
    na.rm = TRUE
  )
  names(pop_area_df) <- c("pu_id_unfiltered", "pu_area_km2")

  # Keep only PUs with total area ≥ min_patch_size500
  keep_pu <- sort(
    pop_area_df$pu_id_unfiltered[
      pop_area_df$pu_area_km2 >= species_df$min_patch_size500[i]
    ]
  )

  if (!length(keep_pu)) {
    log_step(sci, "NO_PUs_GE_min_patch_size500 → SKIP_CONNECTIVITY/WRITE")
    next
  }

  # Final PU IDs: reindex kept PUs to 1..n
  patch_to_pop$pu_id_final <- match(patch_to_pop$pu_id_unfiltered, keep_pu)
  patch_to_pop_kept <- patch_to_pop[!is.na(patch_to_pop$pu_id_final),
                                    c("patch_id", "pu_id_final")]

  #### 5.5 Final patch IDs and patch raster --------------------------------
  log_step(sci, "PATCH_REINDEX")

  # Keep only patches that belong to retained PUs and reindex to 1..n
  keep_patch_ids <- sort(patch_to_pop_kept$patch_id)

  patch_minpop_rast <- terra::classify(
    kept_ids_full,
    rcl    = cbind(as.integer(keep_patch_ids), seq_along(keep_patch_ids)),
    others = NA_integer_
  )

  # Patch lookup rows: species, patch_id (final), PU ID, patch area
  final_patch_ids <- seq_along(keep_patch_ids)
  names(final_patch_ids) <- as.character(keep_patch_ids)

  all_patch_lookup <- rbind(
    all_patch_lookup,
    data.frame(
      species        = sci,
      patch_id       = final_patch_ids[as.character(patch_to_pop_kept$patch_id)],
      pu_id          = patch_to_pop_kept$pu_id_final,
      patch_area_km2 = patches_tab$patch_area_km2[
        match(patch_to_pop_kept$patch_id, patches_tab$patch_id)
      ],
      stringsAsFactors = FALSE
    )
  )

  #### 5.6 Connectivity within each PU -------------------------------------
  log_step(sci, "CONNECTIVITY")

  # Undirected edges between kept patches only
  ei <- integer()
  ej <- integer()
  for (ii in seq_along(nb)) {
    nbrs <- as.integer(nb[[ii]])
    nbrs <- nbrs[nbrs > ii]
    if (length(nbrs)) {
      ei <- c(ei, rep.int(ii, length(nbrs)))
      ej <- c(ej, nbrs)
    }
  }

  edges <- data.frame(
    patch_i = patches_sf$patch_id[ei],
    patch_j = patches_sf$patch_id[ej]
  )

  edges <- edges[
    edges$patch_i %in% keep_patch_ids &
      edges$patch_j %in% keep_patch_ids, 
  ]

  edges$patch_i <- match(edges$patch_i, keep_patch_ids)
  edges$patch_j <- match(edges$patch_j, keep_patch_ids)

  # Build sparse adjacency (CSR style) per PU
  for (pu in sort(unique(patch_to_pop_kept$pu_id_final))) {

    pu_patches <- sort(match(
      patch_to_pop_kept$patch_id[patch_to_pop_kept$pu_id_final == pu],
      keep_patch_ids
    ))

    patch2id <- seq_along(pu_patches); names(patch2id) <- as.character(pu_patches)
    id2patch <- pu_patches

    sub <- edges[
      edges$patch_i %in% pu_patches &
        edges$patch_j %in% pu_patches, 
    ]

    if (nrow(sub) == 0L) {
      row_ptr <- as.integer(c(0L, rep.int(0L, length(pu_patches))))
      col_idx <- as.integer(integer())
    } else {
      E2 <- rbind(
        data.frame(
          i = patch2id[as.character(sub$patch_i)],
          j = patch2id[as.character(sub$patch_j)]
        ),
        data.frame(
          i = patch2id[as.character(sub$patch_j)],
          j = patch2id[as.character(sub$patch_i)]
        )
      )
      E2 <- E2[E2$i != E2$j, ]
      E2 <- unique(E2)
      E2 <- E2[order(E2$i, E2$j), ]

      split_idx <- split(E2$j, E2$i)
      adj_list <- vector("list", length(pu_patches))
      for (jj in seq_along(adj_list)) {
        adj_list[[jj]] <- as.integer(split_idx[[as.character(jj)]])
      }

      lens    <- vapply(adj_list, length, integer(1))
      row_ptr <- as.integer(c(0L, cumsum(lens)))
      col_idx <- as.integer(unlist(adj_list, use.names = FALSE))
    }

    key <- paste0(sci, "|", pu)

    all_connectivity[[key]] <- list(
      species  = sci,
      pu_id    = pu,
      id2patch = as.integer(id2patch),
      patch2id = as.integer(patch2id),
      row_ptr  = row_ptr,
      col_idx  = col_idx
    )
  }

  #### 5.7 Write patch raster -----------------------------------------------
  log_step(sci, "WRITE_PATCH_RASTER")

  if (!dir.exists("Spatial/Patches")) dir.create("Spatial/Patches", recursive = TRUE)

  terra::writeRaster(
    patch_minpop_rast,
    filename = file.path("Spatial/Patches", paste0(sci, ".tif")),
    overwrite = TRUE,
    wopt = list(
      datatype = "INT4U",
      gdal     = c("TILED=YES", "BLOCKXSIZE=512", "BLOCKYSIZE=512",
                   "COMPRESS=LZW", "BIGTIFF=IF_SAFER")
    )
  )

  log_step(sci, "DONE")
}
```

```{r}
###############################################################################
# 6. Save lookup table and connectivity object
###############################################################################

log_step("ALL", "SAVE_OUTPUTS")

saveRDS(all_patch_lookup, file = file.path("Spatial", "all_patch_lookup.rds"))
saveRDS(all_connectivity, file = file.path("Spatial", "all_connectivity.rds"))
```